
Data Binding - Automatic synchronization of data between the model and view components.
The model is the single-source-of-truth for the application state.
The view is a instant projection of the model at all times. When the model changes, the view reflects the change, and vice versa.
This avoids active manipulation of the DOM and supports bootstrapping and rapid development of web applications.
$scope service in Angular, detects changes to the model and modifies HTML in the view accordingly.
Any modification in the view are updated in the model via controller in the same way.

Controllers add data and methods to $scope as properties
HTML elements select a controller
with ng-controller attribute
in effect for the element and its descendants
Form elements bind to $scope properties
with ng-model attribute
Binding expressions access data and methods
on $scope of their controller
expressions in double-curly braces {{ }} that appear in HTML attribute values and element content
When JavaScript code changes value of a $scope property ...
form elements that refer to them with ng-model are updated
binding expressions that refer to them are updated
When user changes value of an form element ...
$scope property referred to by the ng-model attribute is updated

Use Case and benefits
As the view is just a projection of the model, the controller is completely separated from the view.
This makes testing a snap because it is easy to test your controller in isolation without the view and the related DOM/browser dependency.

ng-model Directive
ng-model directive updated the model when the view changes.
ng-model directive can be used with 
Input
Select
textarea

Overview
A JavaScript constructor function that is used to augment the Angular Scope.
Attached to the DOM via the ng-controller directive.
Contain only the business logic needed for a single view 
Controllers Assigns properties to $scope  at the time in DOM which creates and updates the model. 
Controllers add data and methods to $scope
for use in model bindings (ng-model attribute),
binding expressions {{expression}}
and event handling directives (ex. ng-click)
Controller methods can be created through direct assignment to scope.
$controller service takes care of instantiating controllers.
Can depend on services and invoke their methods
Controllers are not singletons
controller functions are invoked each time the associated view is rendered
local variables in controller functions are lost, so state cannot be maintained in them

Do not use controllers to 
Manipulate DOM — Use data binding and directives instead
Format input — Use angular form controls instead.
Filter output — Use angular filters instead.
Share code or state across controllers — Use angular services instead.
Manage the life-cycle of other components (for example, to create service instances

http://jsfiddle.net/KuldeepGupta/emywcjsh/

1. Updating a temple when input text changes
http://jsfiddle.net/KuldeepGupta/vftytb3p/

2. Data Binding with many text Inputs
http://jsfiddle.net/KuldeepGupta/np0h39qa/

3. Data binding with  different ng-model object
http://jsfiddle.net/KuldeepGupta/wo3t21c5/

4. Clearing the entered name on submit using data binding
http://jsfiddle.net/KuldeepGupta/skthw5o9/
To create a controller
app.controller('name', function (services) { ... });
controller names are typically camel-case with first letter uppercase, ending with “Ctrl”
services is a list of service names this controller uses as separate parameters, not an array
services are provided via dependency injection






To use a controller
add ng-controller attribute to an HTML element
	


Controllers can be added in AngularJS in three ways
Declaring controller as a global function
Declaring controller on entire App
Declaring controller in a module

Declaring Controller for entire App

Angular code can be written more efficiently by creating modules.



The module can now be set as the app module.
		

This approach prevents pollution of global namespace
The module ‘myModule’ will be loaded when Angular app loads and hence the component associated with the main module will also be loaded.
Controllers can also be added to the main module.

http://jsfiddle.net/KuldeepGupta/uyo8kcar/

http://jsfiddle.net/KuldeepGupta/jzpw2ebf/
http://jsfiddle.net/KuldeepGupta/7d0L60m7/
http://jsfiddle.net/KuldeepGupta/ws2c95gt/
Scope and Scope Characteristics
What are Scopes?
Scope is an object that refers to the application model. 
It is an execution context for expressions.
Scopes are arranged in hierarchical structure which mimic the DOM structure of the application.
Provide access to data and methods within the scope of a controller
Scopes can watch expressions and propagate events.

$Scope service
a provided service that can be injected into controllers to access current scope
to add data, $scope.name = value;
to add a method, $scope.fnName = function (...) { ... };
to get parent scope, $scope.parent()

Scopes characteristics
Scopes provide APIs ($watch) to observe model mutations.
Scopes provide APIs ($apply) to propagate any model changes through the system into the view from controllers, services, Angular event handlers. Scopes are arranged in hierarchical structure which mimic the DOM structure of the application.
Scopes can be nested. Nested scopes are either "child scopes" or "isolate scopes". 
A "child scope" (prototypically) inherits properties from its parent scope. An "isolate scope" does not.
Scopes provide context against which expressions are evaluated. 

Scope as a Data-Model
Scope is the glue between application controller and the view.
 It is an execution context for expressions.
$watch expressions on the scope allows the directives to be notified of property changes, which allows the directive to render the updated value to the DOM.
Both controllers and directives have reference to the scope, but not to each other which isolates the controller from the directive as well as from the DOM which make the controllers view agnostic.
Expressions are always evaluated in the local scope.
$rootScope is one instance per an Angular app and shared globally for all the controllers of the application
A model belongs to  one and only one scope
Any property on $scope object can be used in the view expressions.
Following directives automatically create scope :
ng-app(Root Scope)
ng-controller 
ng-repeat
http://jsfiddle.net/KuldeepGupta/7bpczjt2/

Scope Hierarchies
Scopes are usually connected via a hierarchy & the child scope has access to parent scope properties.
lookup starts at scope of controller and proceeds upward through scope hierarchy
Each Angular application has exactly one root scope, but may have several child scopes.
Creation of multiple scopes is also supported by Angular as some directives create new child scopes.
A child scope normally prototypically inherits from its parent scope.
New scopes automatically become children of their parent scope. This will create a tree structure. Which will be parallel to the DOM.
On encountering {{ emailed }}, the scope associated with the given element is checked.
If such a property is not found, Angular searches with the parent scope and move on until the root scope is reached.
Having a '.' in your models will ensure that prototypal inheritance is in play.
$parent.parentScopeProperty in the child scope prevent the child scope from creating its own property.
The following create new child scopes, and inherit prototypically: ng-repeat, ng-include, ng-switch, ng-view, ng-controller, directive with scope:true , directive with transclude:true.
The following creates a new scope which does not inherit prototypically: directive with scope: { … }. This creates an “isolate” scope.
By default, directives do not create new scope -- i.e., the default is scope:false.
For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.

Scope Types
Parent Scope (scope: false)—This is the default case. If your directive doesn't manipulate the parent scope properties you might not need a new scope. In this case, using the parent scope is okay.
Child Scope (scope:true)—This creates a new child scope for a directive which prototypically inherits from the parent scope. If the properties and functions you set on the scope are not relevant to other directives and the parent, you should probably create a new child scope. With this you also have all the scope properties and functions defined by the parent.
Isolated Scope (scope:{})— This is like a sandbox! You need this if the directive you're going to build is self-contained and reusable. Your directive might be creating many scope properties and functions which are meant for internal use, and should never be seen by the outside world. If this is the case, it’s better to have an isolated scope. The isolated scope, as expected, does not inherit the parent scope.








